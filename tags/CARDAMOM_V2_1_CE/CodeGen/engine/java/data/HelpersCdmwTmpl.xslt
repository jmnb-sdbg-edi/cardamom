<?xml version="1.0" encoding="utf-8"?>
<!-- ===================================================================== -->
<!--
 * This file is part of CARDAMOM (R) which is jointly developed by THALES
 * and SELEX-SI. It is derivative work based on PERCO Copyright (C) THALES
 * 2000-2003. All rights reserved.
 * 
 * Copyright (C) THALES 2004-2005. All rights reserved
 * 
 * CARDAMOM is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Library General Public License as published
 * by the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * CARDAMOM is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with CARDAMOM; see the file COPYING. If not, write to the
 * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-->
<!-- ===================================================================== -->


<xsl:stylesheet version="1.1"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:UML="org.omg/UML1.3"
   xmlns:date="java:java.util.Date">



<!--
   This template generates a document header for the generated files.

   @param _lang   The implementation language.
-->
<xsl:template name="docHeader">
   <xsl:param name="_lang"/>

   <!--
      Lower case _lang to facilitate string comparisons.
   -->
   <xsl:variable name="implLang" select="translate($_lang, $ucase, $lcase)"/>

   <xsl:choose>
      <xsl:when test="$implLang = 'cpp' or $implLang = 'java'">
         <xsl:value-of select="$lf"/>
         <xsl:value-of select="concat('/* ===================================================================== */', $lf)"/>
         <xsl:value-of select="concat('/*', $lf)"/>
         <xsl:value-of select="concat(' * This file is part of CARDAMOM (R) which is jointly developed by THALES ', $lf)"/>
         <xsl:value-of select="concat(' * and SELEX-SI. ', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * It is derivative work based on PERCO Copyright (C) THALES 2000-2003. ', $lf)"/>
         <xsl:value-of select="concat(' * All rights reserved.', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * CARDAMOM is free software; you can redistribute it and/or modify it under ', $lf)"/>
         <xsl:value-of select="concat(' * the terms of the GNU Library General Public License as published by the', $lf)"/>
         <xsl:value-of select="concat(' * Free Software Foundation; either version 2 of the License, or (at your ', $lf)"/>
         <xsl:value-of select="concat(' * option) any later version. ', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * CARDAMOM is distributed in the hope that it will be useful, but WITHOUT ', $lf)"/>
         <xsl:value-of select="concat(' * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or ', $lf)"/>
         <xsl:value-of select="concat(' * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public ', $lf)"/>
         <xsl:value-of select="concat(' * License for more details. ', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * You should have received a copy of the GNU Library General ', $lf)"/>
         <xsl:value-of select="concat(' * Public License along with CARDAMOM; see the file COPYING. If not, write to ', $lf)"/>
         <xsl:value-of select="concat(' * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.', $lf)"/>
         <xsl:value-of select="concat('*/', $lf)"/>
         <xsl:value-of select="concat('/* ===================================================================== */', $lf)"/>
         <xsl:value-of select="$lf"/>
         <xsl:value-of select="concat('/* =========================================================================== * ', $lf)"/>
         <xsl:value-of select="concat(' * This code has been generated by ', $appName, ' ', $appVersion, $lf)"/>
         <xsl:if test="function-available('date:to-string') and function-available('date:new')">
             <xsl:value-of select="concat(' * on ', date:to-string(date:new()), $lf)"/>
         </xsl:if>
         <xsl:value-of select="concat(' * DO NOT EDIT !!!', $lf)"/>
         <xsl:value-of select="concat(' * =========================================================================== */', $lf)"/>
      </xsl:when>
      <xsl:when test="$implLang = 'ada'">
         <xsl:value-of select="$lf"/>
         <xsl:value-of select="concat('-- * ===================================================================== *', $lf)"/>
         <xsl:value-of select="concat('-- * This file is part of CARDAMOM (R) which is jointly developed by THALES ', $lf)"/>
         <xsl:value-of select="concat('-- * and SELEX-SI. ', $lf)"/>
         <xsl:value-of select="concat('-- * ', $lf)"/>
         <xsl:value-of select="concat('-- * It is derivative work based on PERCO Copyright (C) THALES 2000-2003. ', $lf)"/>
         <xsl:value-of select="concat('-- * All rights reserved.', $lf)"/>
         <xsl:value-of select="concat('-- * ', $lf)"/>
         <xsl:value-of select="concat('-- * CARDAMOM is free software; you can redistribute it and/or modify it under ', $lf)"/>
         <xsl:value-of select="concat('-- * the terms of the GNU Library General Public License as published by the', $lf)"/>
         <xsl:value-of select="concat('-- * Free Software Foundation; either version 2 of the License, or (at your ', $lf)"/>
         <xsl:value-of select="concat('-- * option) any later version. ', $lf)"/>
         <xsl:value-of select="concat('-- * ', $lf)"/>
         <xsl:value-of select="concat('-- * CARDAMOM is distributed in the hope that it will be useful, but WITHOUT ', $lf)"/>
         <xsl:value-of select="concat('-- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or ', $lf)"/>
         <xsl:value-of select="concat('-- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public ', $lf)"/>
         <xsl:value-of select="concat('-- * License for more details. ', $lf)"/>
         <xsl:value-of select="concat('-- * ', $lf)"/>
         <xsl:value-of select="concat('-- * You should have received a copy of the GNU Library General ', $lf)"/>
         <xsl:value-of select="concat('-- * Public License along with CARDAMOM; see the file COPYING. If not, write to ', $lf)"/>
         <xsl:value-of select="concat('-- * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.', $lf)"/>
         <xsl:value-of select="concat('-- * ===================================================================== *', $lf)"/>
         <xsl:value-of select="$lf"/>
         <xsl:value-of select="concat('-- * =========================================================================== *', $lf)"/>
         <xsl:value-of select="concat('-- * This code has been generated by ', $appName, ' ', $appVersion, $lf)"/>
         <xsl:if test="function-available('date:to-string') and function-available('date:new')">
             <xsl:value-of select="concat('-- * on ', date:to-string(date:new()), $lf)"/>
         </xsl:if>
         <xsl:value-of select="concat('-- * DO NOT EDIT !!!', $lf)"/>
         <xsl:value-of select="concat('-- * =========================================================================== *', $lf)"/>
      </xsl:when>
      <xsl:when test="$implLang = 'xml'">
         <xsl:value-of select="$lf"/>
         <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text><xsl:value-of select="$lf"/>
         <xsl:value-of select="concat(' * ===================================================================== *', $lf)"/>
         <xsl:value-of select="concat(' * This file is part of CARDAMOM (R) which is jointly developed by THALES ', $lf)"/>
         <xsl:value-of select="concat(' * and SELEX-SI. ', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * It is derivative work based on PERCO Copyright (C) THALES 2000-2003. ', $lf)"/>
         <xsl:value-of select="concat(' * All rights reserved.', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * CARDAMOM is free software; you can redistribute it and/or modify it under ', $lf)"/>
         <xsl:value-of select="concat(' * the terms of the GNU Library General Public License as published by the', $lf)"/>
         <xsl:value-of select="concat(' * Free Software Foundation; either version 2 of the License, or (at your ', $lf)"/>
         <xsl:value-of select="concat(' * option) any later version. ', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * CARDAMOM is distributed in the hope that it will be useful, but WITHOUT ', $lf)"/>
         <xsl:value-of select="concat(' * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or ', $lf)"/>
         <xsl:value-of select="concat(' * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public ', $lf)"/>
         <xsl:value-of select="concat(' * License for more details. ', $lf)"/>
         <xsl:value-of select="concat(' * ', $lf)"/>
         <xsl:value-of select="concat(' * You should have received a copy of the GNU Library General ', $lf)"/>
         <xsl:value-of select="concat(' * Public License along with CARDAMOM; see the file COPYING. If not, write to ', $lf)"/>
         <xsl:value-of select="concat(' * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.', $lf)"/>
         <xsl:value-of select="concat(' * ===================================================================== *', $lf)"/>
         <xsl:text disable-output-escaping="yes">--&gt;</xsl:text><xsl:value-of select="$lf"/>
         <xsl:value-of select="$lf"/>
         <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text><xsl:value-of select="$lf"/>
         <xsl:value-of select="concat('* =========================================================================== *', $lf)"/>
         <xsl:value-of select="concat('* This code has been generated by ', $appName, ' ', $appVersion, $lf)"/>
         <xsl:if test="function-available('date:to-string') and function-available('date:new')">
             <xsl:value-of select="concat('* on ', date:to-string(date:new()), $lf)"/>
         </xsl:if>
         <xsl:value-of select="concat('* DO NOT EDIT !!!', $lf)"/>
         <xsl:value-of select="concat('* =========================================================================== *', $lf)"/>
         <xsl:text disable-output-escaping="yes">--&gt;</xsl:text><xsl:value-of select="$lf"/>
      </xsl:when>
   </xsl:choose>
</xsl:template> <!-- end of template docHeader -->



<!--
   This template checks whether an XMI description exists 
   for a given CORBA module.<br>
   If a CORBA module is not found in the XMI document, the process
   stops immediately.

   @param _module   The module to check.
-->
<xsl:template name="checkModule">
   <xsl:param name="_module"/>

   <xsl:if test="boolean(key('moduleByName', $_module))">
      <xsl:message terminate="yes">
         <xsl:value-of select="concat('FAILURE : The CORBA module ',  $_module, ' does not exist in the XMI document.')"/>
      </xsl:message>
   </xsl:if>
</xsl:template> <!-- end of template checkModule -->



<!--
   This template checks whether one of the 
   /cdmw/programs/program/services/lifecycle/framework implements
   the strategy passed as parameter.

   @param _strategy   The strategy to check.
-->
<xsl:template name="checkStrategy">
   <xsl:param name="_strategy"/>
   <!--
      Parameters below are used for recursiveness.
   -->
   <xsl:param name="_index" select="1"/>
   <xsl:param name="_found" select="''"/>

   <!--
      References to some nodes.
   -->
   <xsl:variable name="frameworkNodes" select="$cdmwNode/programs/program/services/lifecycle/framework"/>
   
   <xsl:choose>
      <xsl:when test="$_index &lt;= count($frameworkNodes)">
         <xsl:variable name="frameworkIdref" select="$frameworkNodes[$_index]/@idref"/>
         
         <!--
            Find the matching node /cdmw/lifecycle-frameworks/lifecycle-framework.
         -->
         <xsl:variable name="lifecycleFrameworkNode" select="$lifecycleFrameworkNodes[@id = $frameworkIdref]"/>
         <xsl:call-template name="checkStrategy">
            <xsl:with-param name="_strategy" select="$_strategy"/>
            <xsl:with-param name="_index" select="$_index + 1"/>
            <xsl:with-param name="_found" select="concat($_found, ' ', $lifecycleFrameworkNode/*/@category)"/>
         </xsl:call-template>
      </xsl:when>
      <!--
         If the strategy we're checking is among the strategies found,
         then return true().
      -->
      <xsl:otherwise>
         <xsl:choose>
            <xsl:when test="contains($_found, $_strategy)">
               <xsl:value-of select="true()"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="false()"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template>



<!--
   This template returns the IDL identifier of a node.

   @param _name   The node name.
-->

<xsl:template name="getIdlIdentifier">
   <xsl:param name="_name"/>
   
   <xsl:variable name="nodeType">
      <xsl:choose>
         <xsl:when test="boolean(key('exceptionByName', $_name))">
            <xsl:value-of select="'exceptionByName'"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:value-of select="'classByName'"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>
   <xsl:value-of select="key($nodeType, $_name)/UML:ModelElement.taggedValue/UML:TaggedValue/@value"/>

</xsl:template>



<!--
   This template returns the scoped name of a node.

   @param _name   The node name.
   @param _lang   The implementation language.
-->

<xsl:template name="getScopedName">
   <xsl:param name="_name"/>
   <xsl:param name="_lang" select="'cpp'"/>
   <!--
      Parameters below are used for recursiveness.
   -->
   <xsl:param name="_scopedName"/>
   
   <xsl:variable name="implLang" select="translate($_lang, $ucase, $lcase)"/>

   <!--
      Define the separator to use.
   -->
   <xsl:variable name="sep">
      <xsl:choose>
         <xsl:when test="$implLang = 'cpp'">
            <xsl:value-of select="$cppSep"/>
         </xsl:when>
         <xsl:when test="$implLang = 'ada'">
            <xsl:value-of select="$adaSep"/>
         </xsl:when>
         <xsl:when test="$implLang = 'java'">
            <xsl:value-of select="$javaSep"/>
         </xsl:when>
      </xsl:choose>
   </xsl:variable>

   <!--
      Get the node type for _name.<br>
      Note: A bug prevents us from assigning the node to this variable.
      Instead of this, we will assign it a string.
   -->
   <xsl:variable name="nameNodeType">
      <xsl:choose>
         <!--
            Is it a Class ?
         -->
         <xsl:when test="boolean(key('classByName', $_name))">
            <xsl:value-of select="'classByName'"/>
         </xsl:when>
         <!--
            Or is it an Exception ?
         -->
         <xsl:when test="boolean(key('exceptionByName', $_name))">
            <xsl:value-of select="'exceptionByName'"/>
         </xsl:when>
         <!--
            Or is it a Package ?
         -->
         <xsl:otherwise test="boolean(key('moduleByName', $_name))">
            <xsl:value-of select="'moduleByName'"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>
   <xsl:variable name="nameNode" select="key($nameNodeType, $_name)"/>

   <!--
      Building the scope.
   -->
   <xsl:choose>
      <xsl:when test="boolean($nameNode)">
         <xsl:variable name="containerName">
            <xsl:choose>
               <xsl:when test="boolean(key('moduleById', $nameNode/@namespace))">
                  <xsl:value-of select="key('moduleById', $nameNode/@namespace)/@name"/>
               </xsl:when>
               <xsl:when test="boolean(key('classById', $nameNode/@namespace))">
                  <xsl:value-of select="key('classById', $nameNode/@namespace)/@name"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:value-of select="key('classById', $nameNode/@owner)/@name"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:variable>

         <!--
            Go up a level and see what happens.
         -->
         <xsl:call-template name="getScopedName">
            <xsl:with-param name="_name" select="$containerName"/>
            <xsl:with-param name="_lang" select="$_lang"/>
            <xsl:with-param name="_scopedName">
               <xsl:choose>
                  <xsl:when test="string-length($_scopedName) = 0">
                     <xsl:choose>
                        <xsl:when test="string-length($containerName) > 0">
                           <xsl:value-of select="concat($containerName, $sep, $_name)"/>
                        </xsl:when>
                        <xsl:otherwise>
                           <xsl:value-of select="$_name"/>
                        </xsl:otherwise>
                     </xsl:choose>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:choose>
                        <xsl:when test="string-length($containerName) > 0">
                           <xsl:value-of select="concat($containerName, $sep, $_scopedName)"/>
                        </xsl:when>
                        <xsl:otherwise>
                           <xsl:value-of select="$_scopedName"/>
                        </xsl:otherwise>
                     </xsl:choose>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:with-param>
         </xsl:call-template>
      </xsl:when>
      <!--
         End of recursiveness : we reached UML:Model.
      -->
      <xsl:otherwise>
         <xsl:choose>
            <xsl:when test="$implLang = 'java'">
               <xsl:variable name="className">
                  <xsl:call-template name="getLastToken">
                     <xsl:with-param name="_string" select="$_scopedName"/>
                     <xsl:with-param name="_separator" select="$javaSep"/>
                  </xsl:call-template>
               </xsl:variable>
               <xsl:variable name="idlIdentifier">
                  <xsl:call-template name="getIdlIdentifier">
                     <xsl:with-param name="_name" select="$className"/>
                  </xsl:call-template>
               </xsl:variable>
               <xsl:variable name="javaPrefix">
                  <xsl:choose>
                     <xsl:when test="string-length($idlIdentifier) > 0">
                        <xsl:value-of select="substring-after(substring-before($idlIdentifier, '/'), ':')"/>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:value-of select="$idlPragmaPrefix"/>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:variable>
               <xsl:variable name="prefix">
                  <xsl:call-template name="reverseList">
                     <xsl:with-param name="_list" select="$javaPrefix"/>
                     <xsl:with-param name="_separator" select="$sep"/>
                  </xsl:call-template>
               </xsl:variable>
               <xsl:variable name="count">
                  <xsl:call-template name="countTokens">
                     <xsl:with-param name="_string" select="$_scopedName"/>
                     <xsl:with-param name="_separator" select="$javaSep"/>
                  </xsl:call-template>
               </xsl:variable>
               <!--
                  if the class is defined inside an interface
                  we must add 'Package' to the end of the interface name
               -->
               <xsl:variable name="javaScope">
                  <xsl:variable name="scope">
                     <xsl:call-template name="getScope">
                        <xsl:with-param name="_name" select="$_scopedName"/>
                        <xsl:with-param name="_lang" select="'java'"/>
                     </xsl:call-template>
                  </xsl:variable>
                  <xsl:choose>
                     <xsl:when test="$count > 2">
                        <xsl:value-of select="concat($scope, 'Package')"/>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:value-of select="$scope"/>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:variable>
               <xsl:value-of select="concat($prefix, $sep, $javaScope, $sep, $className)"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="$_scopedName"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template getScopedName -->



<!--
   This template returns the scope of a node or the scope of a scoped name.

   @param _name   The node name or the scoped name.
   @param _lang   The implementation language.
-->

<xsl:template name="getScope">
   <xsl:param name="_name"/>
   <xsl:param name="_lang" select="'cpp'"/>

   <xsl:variable name="implLang" select="translate($_lang, $ucase, $lcase)"/>

   <!--
      Define the separator to use.
   -->
   <xsl:variable name="sep">
      <xsl:choose>
         <xsl:when test="$implLang = 'cpp'">
            <xsl:value-of select="$cppSep"/>
         </xsl:when>
         <xsl:when test="$implLang = 'ada'">
            <xsl:value-of select="$adaSep"/>
         </xsl:when>
         <xsl:when test="$implLang = 'java'">
            <xsl:value-of select="$javaSep"/>
         </xsl:when>
      </xsl:choose>
   </xsl:variable>

   <xsl:choose>
      <!--
         Node name.
      -->
      <xsl:when test="not(contains($_name, $sep))">
         <!--
            Get the scoped name.
         -->
         <xsl:variable name="scopedName">
            <xsl:call-template name="getScopedName">
               <xsl:with-param name="_name" select="$_name"/>
               <xsl:with-param name="_lang" select="$_lang"/>
            </xsl:call-template>
         </xsl:variable>
         <!--
            Return the scope.
         -->
         <xsl:call-template name="removeLastToken">
            <xsl:with-param name="_scopedName" select="$scopedName"/>
            <xsl:with-param name="_sep" select="$sep"/>
         </xsl:call-template>
      </xsl:when>
      <!--
         Scoped name.
      -->
      <xsl:otherwise>
         <xsl:call-template name="removeLastToken">
            <xsl:with-param name="_scopedName" select="$_name"/>
            <xsl:with-param name="_sep" select="$sep"/>
         </xsl:call-template>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template getScope -->



<!--
    This template removes the last token as well as the last separator.
    
    @param _scopedName  The scoped name.
    @param _sep         The token separator.
-->
<xsl:template name="removeLastToken">
    <xsl:param name="_scopedName"/>
    <xsl:param name="_sep" select="$cppSep"/>
    <!-- Parameters are used for recursiveness -->
    <xsl:param name="_returnVal" select="''"/>
    
    <xsl:choose>
        <xsl:when test="contains($_scopedName, $_sep)">
            <xsl:call-template name="removeLastToken">
                <xsl:with-param name="_scopedName" select="substring-after($_scopedName, $_sep)"/>
                <xsl:with-param name="_sep" select="$_sep"/>
                <xsl:with-param name="_returnVal">
                    <xsl:choose>
                        <xsl:when test="string-length($_returnVal) > 0">
                            <xsl:value-of select="concat($_returnVal, $_sep, substring-before($_scopedName, $_sep))"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="substring-before($_scopedName, $_sep)"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$_returnVal"/>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>


<!--
   This template returns the type of a parameter of an operation.

   @param _paramNode  The parameter node.
   @param _lang       The implementaton language.
-->

<xsl:template name="getParameterType">
   <xsl:param name="_paramNode"/>
   <xsl:param name="_lang" select="'cpp'"/>

   <xsl:call-template name="getType">
      <xsl:with-param name="_id" select="$_paramNode/@type"/>
      <xsl:with-param name="_kind" select="$_paramNode/@kind"/>
      <xsl:with-param name="_lang" select="$_lang"/>
   </xsl:call-template>
</xsl:template> <!-- end of template getParameterType -->



<!--
   This template returns the type of an element according to its @stereotype.

   @param _id            The stereotype id.
   @param _kind          The kind (in, inout, return) to use for the mapping.
   @param _asObjRefVar   Returns the type as an obj reference variable.
   @param _lang          The implementation language.
-->
<xsl:template name="getType">
   <xsl:param name="_id"/>
   <xsl:param name="_kind"/>
   <xsl:param name="_asObjRefVar" select="false()"/>
   <xsl:param name="_lang" select="'cpp'"/>

   <xsl:variable name="implLang" select="translate($_lang, $ucase, $lcase)"/>

   <!--
      Is it a CORBA primitive type ?
   -->
   <xsl:variable name="stereotypeNode" select="key('stereotypeById', $_id)"/>
   <xsl:choose>
      <xsl:when test="boolean($stereotypeNode) and 
                      not($stereotypeNode/@name = 'CORBATypedef') and 
                      not($stereotypeNode/@name = 'CORBAInterface') and
                      not($stereotypeNode/@name = 'CORBAComponent') and
                      not($stereotypeNode/@name = 'CORBAHome')">
         <xsl:choose>
            <xsl:when test="$implLang = 'cpp'">
               <xsl:call-template name="mapToCPP">
                  <xsl:with-param name="_paramKind" select="$_kind"/>
                  <xsl:with-param name="_stereotype" select="$stereotypeNode/@name"/>
                  <xsl:with-param name="_asObjRefVar" select="$_asObjRefVar"/>
                  <xsl:with-param name="_isVariable">
                     <xsl:call-template name="isVariableSizeTypeCPP">
                        <xsl:with-param name="_typeId" select="$_id"/>
                     </xsl:call-template>
                  </xsl:with-param>
               </xsl:call-template>
            </xsl:when>
            <xsl:when test="$implLang = 'ada'">
               <xsl:call-template name="mapToADA">
                  <xsl:with-param name="_paramKind" select="$_kind"/>
                  <xsl:with-param name="_stereotype" select="$stereotypeNode/@name"/>
               </xsl:call-template>
            </xsl:when>
            <xsl:when test="$implLang = 'java'">
               <xsl:call-template name="mapToJAVA">
                  <xsl:with-param name="_stereotype" select="$stereotypeNode/@name"/>
                  <xsl:with-param name="_paramKind" select="$_kind"/>
               </xsl:call-template>
            </xsl:when>
         </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
         <!--
            Could it be a CORBA alias ?
         -->
         <xsl:variable name="node" select="key('classById', $_id)"/>
         <xsl:choose>
            <xsl:when test="$implLang = 'cpp' or $implLang = 'java' or ($implLang = 'ada' and $_kind = 'return')">
               <xsl:choose>
                  <xsl:when test="key('stereotypeById', $node/@stereotype)/@name = 'CORBATypedef'">
                     <xsl:call-template name="aliasOriginalType">
                        <xsl:with-param name="_aliasName" select="$node/@name"/>
                        <xsl:with-param name="_kind" select="$_kind"/>
                        <xsl:with-param name="_generalization" select="$node/UML:GeneralizableElement.generalization/UML:Generalization/@xmi.idref"/>
                        <xsl:with-param name="_asObjRefVar" select="$_asObjRefVar"/>
                        <xsl:with-param name="_lang" select="$_lang"/>
                     </xsl:call-template>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:choose>
                        <xsl:when test="$implLang = 'cpp'">
                           <xsl:call-template name="mapToCPP">
                              <xsl:with-param name="_paramKind" select="$_kind"/>
                              <xsl:with-param name="_stereotype" select="key('stereotypeById', $node/@stereotype)/@name"/>
                              <xsl:with-param name="_scopedName">
                                 <xsl:call-template name="getScopedName">
                                    <xsl:with-param name="_name" select="key('classById', $_id)/@name"/>
                                 </xsl:call-template>
                              </xsl:with-param>
                              <xsl:with-param name="_asObjRefVar" select="$_asObjRefVar"/>
                              <xsl:with-param name="_isVariable">
                                 <xsl:call-template name="isVariableSizeTypeCPP">
                                    <xsl:with-param name="_typeId" select="$_id"/>
                                 </xsl:call-template>
                              </xsl:with-param>
                           </xsl:call-template>
                        </xsl:when>
                        <xsl:when test="$_lang = 'ada'">
                           <xsl:call-template name="mapToADA">
                              <xsl:with-param name="_paramKind" select="$_kind"/>
                              <xsl:with-param name="_stereotype" select="key('stereotypeById', $node/@stereotype)/@name"/>
                              <xsl:with-param name="_scopedName">
                                 <xsl:call-template name="getScopedName">
                                    <xsl:with-param name="_name" select="key('classById', $_id)/@name"/>
                                    <xsl:with-param name="_lang" select="$_lang"/>
                                 </xsl:call-template>
                              </xsl:with-param>
                           </xsl:call-template>
                        </xsl:when>
                        <xsl:when test="$_lang = 'java'">
                           <xsl:call-template name="mapToJAVA">
                              <xsl:with-param name="_stereotype" select="key('stereotypeById', $node/@stereotype)/@name"/>
                              <xsl:with-param name="_paramKind" select="$_kind"/>
                              <xsl:with-param name="_xmiId" select="$_id"/>
                           </xsl:call-template>
                        </xsl:when>
                     </xsl:choose>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:when>
            <xsl:when test="$implLang = 'ada'">
               <xsl:call-template name="getScopedName">
                  <xsl:with-param name="_name" select="$node/@name"/>
                  <xsl:with-param name="_lang" select="$_lang"/>
               </xsl:call-template>
            </xsl:when>
         </xsl:choose>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template getType -->



<!--
   This template determines the original type of a CORBA alias.

   @param _aliasName        The alias name.
   @param _kind             The kind (in, inout, return) to use for the mapping.
   @param _generalization   The xmi.id of the generalization of the CORBA alias.
   @param _asObjRefVar      Returns the type as an obj reference variable.
   @param _lang             The implementation language.
-->

<xsl:template name="aliasOriginalType">
   <xsl:param name="_aliasName"/>
   <xsl:param name="_kind" select="'in'"/>
   <xsl:param name="_generalization"/>
   <xsl:param name="_asObjRefVar" select="false()"/>
   <xsl:param name="_lang" select="'cpp'"/>

   <xsl:variable name="implLang" select="translate($_lang, $ucase, $lcase)"/>

   <!--
      Is the parent a CORBA primitive stereotype ?
   -->
   <xsl:variable name="generalizationNode" select="key('generalizationById', $_generalization)"/>
   <xsl:variable name="parentStereotype" select="key('stereotypeById', $generalizationNode/UML:Generalization.supertype/UML:GeneralizableElement/@xmi.idref)"/>
   <xsl:variable name="parentStereotypeName" select="$parentStereotype/@name"/>
   <xsl:choose>
      <xsl:when test="boolean($parentStereotype)">
         <xsl:choose>
            <xsl:when test="$implLang = 'cpp'">
               <xsl:call-template name="mapToCPP">
                  <xsl:with-param name="_paramKind" select="$_kind"/>
                  <xsl:with-param name="_stereotype" select="$parentStereotypeName"/>
                  <xsl:with-param name="_scopedName">
                     <xsl:call-template name="getScopedName">
                        <xsl:with-param name="_name" select="$_aliasName"/>
                     </xsl:call-template>
                  </xsl:with-param>
                  <xsl:with-param name="_asObjRefVar" select="$_asObjRefVar"/>
                  <xsl:with-param name="_isVariable">
                     <xsl:call-template name="isVariableSizeTypeCPP">
                        <xsl:with-param name="_typeId" select="$parentStereotype/@xmi.id"/>
                     </xsl:call-template>
                  </xsl:with-param>
               </xsl:call-template>
            </xsl:when>
            <xsl:when test="$implLang = 'ada'">
               <xsl:call-template name="mapToADA">
                  <xsl:with-param name="_paramKind" select="$_kind"/>
                  <xsl:with-param name="_stereotype" select="$parentStereotypeName"/>
                  <xsl:with-param name="_scopedName">
                     <xsl:call-template name="getScopedName">
                        <xsl:with-param name="_name" select="$_aliasName"/>
                     </xsl:call-template>
                  </xsl:with-param>
               </xsl:call-template>
            </xsl:when>
            <xsl:when test="$implLang = 'java'">
               <xsl:call-template name="mapToJAVA">
                  <xsl:with-param name="_stereotype" select="$parentStereotypeName"/>
                  <xsl:with-param name="_paramKind" select="$_kind"/>
                  <xsl:with-param name="_xmiId" select="key('classByName', $_aliasName)/@xmi.id"/>
               </xsl:call-template>
            </xsl:when>
         </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
         <!--
            Get the parent node.
         -->
         <xsl:variable name="parentNode" select="key('classById', key('generalizationById', $_generalization)/UML:Generalization.supertype/UML:GeneralizableElement/@xmi.idref)"/>
         
         <!--
            Is it another alias ?
         -->
         <xsl:variable name="stereotypeNode" select="key('stereotypeById', $parentNode/@stereotype)"/>
         <xsl:choose>
            <xsl:when test="$stereotypeNode/@name = 'CORBATypedef'">
               <xsl:call-template name="aliasOriginalType">
                  <xsl:with-param name="_aliasName" select="$_aliasName"/>
                  <xsl:with-param name="_kind" select="$_kind"/>
                  <xsl:with-param name="_generalization" select="$parentNode/UML:GeneralizableElement.generalization/UML:Generalization/@xmi.idref"/>
                  <xsl:with-param name="_asObjRefVar" select="$_asObjRefVar"/>
                  <xsl:with-param name="_lang" select="$_lang"/>
               </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
               <xsl:choose>
                  <xsl:when test="$implLang = 'cpp'">
                     <xsl:call-template name="mapToCPP">
                        <xsl:with-param name="_paramKind" select="$_kind"/>
                        <xsl:with-param name="_stereotype" select="$stereotypeNode/@name"/>
                        <xsl:with-param name="_scopedName">
                           <xsl:call-template name="getScopedName">
                              <xsl:with-param name="_name" select="$parentNode/@name"/>
                           </xsl:call-template>
                        </xsl:with-param>
                        <xsl:with-param name="_asObjRefVar" select="$_asObjRefVar"/>
                        <xsl:with-param name="_isVariable">
                           <xsl:call-template name="isVariableSizeTypeCPP">
                              <xsl:with-param name="_typeId" select="$parentNode/@xmi.id"/>
                           </xsl:call-template>
                        </xsl:with-param>
                     </xsl:call-template>
                  </xsl:when>
                  <xsl:when test="$implLang = 'ada'">
                     <xsl:call-template name="mapToADA">
                        <xsl:with-param name="_paramKind" select="$_kind"/>
                        <xsl:with-param name="_stereotype" select="$stereotypeNode/@name"/>
                        <xsl:with-param name="_scopedName">
                           <xsl:call-template name="getScopedName">
                              <xsl:with-param name="_name" select="$parentNode/@name"/>
                           </xsl:call-template>
                        </xsl:with-param>
                     </xsl:call-template>
                  </xsl:when>
                  <xsl:when test="$implLang = 'java'">
                     <xsl:call-template name="mapToJAVA">
                        <xsl:with-param name="_stereotype" select="$stereotypeNode/@name"/>
                        <xsl:with-param name="_paramKind" select="$_kind"/>
                        <xsl:with-param name="_xmiId" select="$parentNode/@xmi.id"/>
                     </xsl:call-template>
                  </xsl:when>
               </xsl:choose>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template aliasOriginalType -->



<!--
   This template returns the xmi.id of the original type of a CORBA alias.

   @param _generalization   The xmi.id of the generalization of the CORBA alias.
-->
<xsl:template name="aliasOriginalTypeId">
   <xsl:param name="_generalization"/>

   <!--
      Is the parent a CORBA primitive stereotype ?
   -->
   <xsl:variable name="generalizationNode" select="key('generalizationById', $_generalization)"/>
   <xsl:variable name="parentStereotype" select="key('stereotypeById', $generalizationNode/UML:Generalization.supertype/UML:GeneralizableElement/@xmi.idref)"/>
   <xsl:variable name="parentStereotypeName" select="$parentStereotype/@name"/>
   <xsl:choose>
      <xsl:when test="boolean($parentStereotype)">
         <xsl:value-of select="$parentStereotype/@xmi.id"/>
      </xsl:when>
      <xsl:otherwise>
         <!--
            Get the parent node.
         -->
         <xsl:variable name="parentNode" select="key('classById', key('generalizationById', $_generalization)/UML:Generalization.supertype/UML:GeneralizableElement/@xmi.idref)"/>
         
         <!--
            Is it another alias ?
         -->
         <xsl:variable name="stereotypeNode" select="key('stereotypeById', $parentNode/@stereotype)"/>
         <xsl:choose>
            <xsl:when test="$stereotypeNode/@name = 'CORBATypedef'">
               <xsl:call-template name="aliasOriginalTypeId">
                  <xsl:with-param name="_generalization" select="$parentNode/UML:GeneralizableElement.generalization/UML:Generalization/@xmi.idref"/>
               </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="$parentNode/@xmi.id"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template aliasOriginalTypeId -->



<!--
   This template takes as input a string containing repository ids
   separated by a space character and prints them out one by one.

   @param _string   The string containing the repository ids.
   @param _lang     The implementation language.
-->

<xsl:template name="printRepositoryIds">
   <xsl:param name="_string"/>
   <xsl:param name="_lang" select="'cpp'"/>

   <xsl:variable name="implLang" select="translate($_lang, $ucase, $lcase)"/>

   <xsl:choose>
      <xsl:when test="contains($_string, ' ')">
         <xsl:variable name="firstRepositoryId" select="substring-before($_string, ' ')"/>
         <xsl:if test="string-length($firstRepositoryId) > 0">
            <xsl:choose>
               <xsl:when test="$implLang = 'ada'">
                  <xsl:text>Corba.To_Corba_String ("</xsl:text><xsl:value-of select="$firstRepositoryId"/><xsl:text>")</xsl:text>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:text>"</xsl:text><xsl:value-of select="$firstRepositoryId"/><xsl:text>"</xsl:text>
               </xsl:otherwise>
            </xsl:choose>
            <xsl:value-of select="concat(',', $lf)"/>
         </xsl:if>
         <!--
            Do the job again with the remaining repository ids.
         -->
         <xsl:call-template name="printRepositoryIds">
            <xsl:with-param name="_string" select="substring-after($_string, ' ')"/>
            <xsl:with-param name="_lang" select="$_lang"/>
         </xsl:call-template>
      </xsl:when>
      <!--
         No more space character found : end of recursiveness.
      -->
      <xsl:otherwise>
         <xsl:choose>
            <xsl:when test="$implLang = 'cpp'">
               <xsl:text>"</xsl:text><xsl:value-of select="$_string"/><xsl:text>"</xsl:text><xsl:value-of select="concat(',', $lf)"/>
            </xsl:when>
            <xsl:when test="$implLang = 'ada'">
               <xsl:value-of select="'Corba.To_Corba_String ('"/>"<xsl:value-of select="$_string"/>"<xsl:value-of select="concat(')', $lf)"/>
            </xsl:when>
            <xsl:when test="$implLang = 'java'">
               <xsl:text>"</xsl:text><xsl:value-of select="$_string"/><xsl:text>"</xsl:text><xsl:value-of select="$lf"/>
            </xsl:when>
         </xsl:choose>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template printRepositoryIds -->



<!--
   This template generates the object list or the number of objects in the list.

   @param _nodeName   The starting point of the search.
   @param _count      If true() then return the number of objects in the list,
                      else return a list of RepositoryId (default behavior).
   @param _lang       The implementation language.
-->
<xsl:template name="getObjectList">
   <xsl:param name="_nodeName"/>
   <xsl:param name="_count" select="false()"/>
   <xsl:param name="_lang" select="'cpp'"/>

   <!--
      References to some nodes.
   -->
   <xsl:variable name="node" select="key('classByName', $_nodeName)"/>

   <!--
      Miscellaneous variables.
   -->
   <xsl:variable name="componentId" select="key('stereotypeByName', 'CCMComponent')/@xmi.id"/>

   <!--
      Get the repository ids.
   -->
   <xsl:variable name="repositoryIds">
      <xsl:call-template name="removeDuplicateTokens">
         <xsl:with-param name="_string">
            <xsl:choose>
               <xsl:when test="$node/@stereotype = $componentId">
                  <xsl:call-template name="getSupportedInterfaceIds">
                     <xsl:with-param name="_componentNode" select="$node"/>
                  </xsl:call-template>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:call-template name="getReturnTypeRepositoryIds">
                     <xsl:with-param name="_operations" select="$node/UML:Namespace.ownedElement/UML:Operation"/>
                  </xsl:call-template>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:with-param>
      </xsl:call-template>
   </xsl:variable>

   <xsl:choose>
      <xsl:when test="$_count">
         <xsl:call-template name="countTokens">
            <xsl:with-param name="_string" select="$repositoryIds"/>
         </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
         <xsl:call-template name="printRepositoryIds">
            <xsl:with-param name="_string" select="$repositoryIds"/>
            <xsl:with-param name="_lang" select="$_lang"/>
         </xsl:call-template>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template getObjectList -->



<!--
   This template returns the repository id of the component as well
   as those of its supported interfaces.

   @param _componentNode   The component to visit.
-->
<xsl:template name="getSupportedInterfaceIds">
   <xsl:param name="_componentNode"/>

   <xsl:variable name="supportedInterfaceIds">
      <xsl:variable name="generalizations" select="key('generalizationById', $_componentNode/UML:GeneralizableElement.generalization/UML:Generalization/@xmi.idref)"/>
      <xsl:for-each select="$generalizations">
         <xsl:call-template name="getInterfaceRepositoryIds">
            <xsl:with-param name="_interfaceNode" select="key('classById', UML:Generalization.supertype/UML:GeneralizableElement/@xmi.idref)"/>
         </xsl:call-template>
      </xsl:for-each>
   </xsl:variable>

   <xsl:value-of select="concat($_componentNode/UML:ModelElement.taggedValue/UML:TaggedValue[@tag = 'typeid']/@value, ' ', $supportedInterfaceIds)"/>
</xsl:template> <!-- end of template getSupportedInterfaceIds -->



<!--
   This template goes through each operation contained in an interface and
   looks for the repository ids of the return types.

   @param _operations   The operations nodeset.
-->
<xsl:template name="getReturnTypeRepositoryIds">
   <xsl:param name="_operations"/>

   <xsl:for-each select="$_operations">
      <xsl:call-template name="getInterfaceRepositoryIds">
         <xsl:with-param name="_interfaceNode" select="key('classById', UML:BehavioralFeature.parameter/UML:Parameter[@kind = 'return']/@type)"/>
      </xsl:call-template>
   </xsl:for-each>
</xsl:template> <!-- end of template getReturnTypeRepositoryIds -->



<!--
   This template returns the repository id of a given interface as well as
   those from its parent interfaces if it has any.

   @param _interfaceNode   The interface node to visit.
-->
<xsl:template name="getInterfaceRepositoryIds">
   <xsl:param name="_interfaceNode"/>

   <xsl:value-of select="concat($_interfaceNode/UML:ModelElement.taggedValue/UML:TaggedValue[@tag = 'typeid']/@value, ' ')"/>

   <!--
      If the interface inherits from other interfaces, visit them also.
   -->
   <xsl:variable name="generalizations" select="key('generalizationById', $_interfaceNode/UML:GeneralizableElement.generalization/UML:Generalization/@xmi.idref)"/>
   <xsl:for-each select="$generalizations">
      <xsl:call-template name="getInterfaceRepositoryIds">
         <xsl:with-param name="_interfaceNode" select="key('classById', UML:Generalization.supertype/UML:GeneralizableElement/@xmi.idref)"/>
      </xsl:call-template>
   </xsl:for-each>
</xsl:template> <!-- end of template getInterfaceRepositoryIds -->



<!--
   This template builds a filename for output.

   @param _lang              The implementation language.
   @param _userDirectory     The user directory. 
   @param _userFilename      The user filename.
   @param _defaultFilename   The default filename.
   @param _fileExtension     The filename extension.
-->
<xsl:template name="buildOutputFilename">
   <xsl:param name="_lang" select="'cpp'"/>
   <xsl:param name="_userDirectory" select="''"/>
   <xsl:param name="_userFilename"/>
   <xsl:param name="_defaultFilename"/>
   <xsl:param name="_fileExtension"/>

   <xsl:variable name="implLang" select="translate($_lang, $ucase, $lcase)"/>

   <!--
      Get the output directory.
   -->
   <xsl:variable name="directory">
      <xsl:choose>
         <xsl:when test="string-length($_userDirectory) > 0">
            <xsl:value-of select="$_userDirectory"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:value-of select="$DIR"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>

   <!--
      Get the output filename.
   -->
   <xsl:variable name="filenameWithoutPath">
      <xsl:choose>
         <xsl:when test="string-length($_userFilename) > 0">
            <xsl:value-of select="$_userFilename"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:choose>
               <xsl:when test="$implLang = 'ada'">
                  <xsl:call-template name="gnatFilename">
                     <xsl:with-param name="_name" select="$_defaultFilename"/>
                  </xsl:call-template>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:value-of select="$_defaultFilename"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>
   <xsl:variable name="filename">
      <xsl:call-template name="addFileExtension">
         <xsl:with-param name="_filename">
            <xsl:choose>
               <!--
                  Store the generated file into the current directory
                  if $directory is null.
               -->
               <xsl:when test="string-length($directory) = 0">
                  <xsl:value-of select="$filenameWithoutPath"/>
               </xsl:when>
               <!--
                  Otherwise, build a path.
               -->
               <xsl:otherwise>
                  <xsl:value-of select="concat($directory, $fileSep, $filenameWithoutPath)"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:with-param>
         <xsl:with-param name="_extension" select="$_fileExtension"/>
      </xsl:call-template>
   </xsl:variable>

   <xsl:value-of select="$filename"/>
</xsl:template> <!-- end of template buildOutputFilename -->



<!--
   This templates returns true() if the valuetype is a primary key.

   @param _typeId   The valuetype id.
-->
<xsl:template name="valuetypeIsPrimaryKey">
   <xsl:param name="_typeId"/>

   <!--
      Finds any associations where the type of the first AssociationEnd equals $_typeId.
   -->
   <xsl:variable name="ccmManagesId" select="key('stereotypeByName', 'CCMManages')/@xmi.id"/>
   <xsl:variable name="associations" select="key('associationBySourceId', $_typeId)[@stereotype = $ccmManagesId]"/>

   <!--
      Among those associations, is there at least one whose first AssociationEnd
      defines a primary key ?
   -->
   <xsl:choose>
      <xsl:when test="count($associations) > 0">
         <xsl:variable name="primarykeyId" select="key('stereotypeByName', 'CCMPrimaryKey')/@xmi.id"/>
         <xsl:variable name="hasPK">
            <xsl:for-each select="$associations">
               <xsl:choose>
                  <xsl:when test="UML:Association.connection/UML:AssociationEnd[1]/@stereotype = $primarykeyId">
                     <xsl:value-of select="true()"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:value-of select="false()"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:for-each>
         </xsl:variable>
         <xsl:value-of select="contains($hasPK, 'true')"/>
      </xsl:when>
      <xsl:otherwise>
         <xsl:value-of select="false()"/>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template valuetypeIsPrimaryKey -->



<!--
   This template returns the managed component xmi.id of a given home.

   @param _homeName   The name of the home to visit.
-->
<xsl:template name="getManagedComponentId">
   <xsl:param name="_homeName"/>

   <!--
      Miscellaneous variables.
   -->
   <xsl:variable name="homeId" select="key('classByName', $_homeName)/@xmi.id"/>
   <xsl:variable name="ccmManagesId" select="key('stereotypeByName', 'CCMManages')/@xmi.id"/>
   <xsl:variable name="ccmManagesAssociation" select="key('associationBySourceId', $homeId)[@stereotype = $ccmManagesId]"/>
   <xsl:variable name="ccmComponentId" select="key('stereotypeByName', 'CCMComponent')/@xmi.id"/>

   <!--
      Return the xmi.id of the managed component.
   -->
   <xsl:value-of select="$ccmManagesAssociation/UML:Association.connection/UML:AssociationEnd[@stereotype = $ccmComponentId]/@type"/>
</xsl:template> <!-- end of template getManagedComponentId -->



<!--
   This template returns true if a component contains 
   at least one read/write attribute.

   @param _componentName   The name of the component to visit.
-->
<xsl:template name="readWriteAttributes">
   <xsl:param name="_componentName"/>

   <!--
      References to some nodes.
   -->
   <xsl:variable name="componentNode" select="key('classByName', $_componentName)"/>

   <!--
      Miscellaneous variables.
   -->
   <xsl:variable name="readonlyEndId" select="key('stereotypeByName', 'readonlyEnd')/@xmi.id"/>
   <xsl:variable name="umlAttributes" select="$componentNode/UML:Namespace.ownedElement/UML:Attribute"/>
   <xsl:variable name="umlAssociations" select="key('associationBySourceId', $componentNode/@xmi.id)"/>

   <!--
      Find all the read/write attributes.
   -->
   <xsl:variable name="searchResult">
      <xsl:for-each select="$umlAttributes|$umlAssociations">
         <xsl:if test="not(boolean(@stereotype) or (@stereotype = $readonlyEndId))">
            <xsl:value-of select="true()"/>
         </xsl:if>
      </xsl:for-each>
   </xsl:variable>

   <xsl:choose>
      <xsl:when test="contains($searchResult, 'true')">
         <xsl:value-of select="true()"/>
      </xsl:when>
      <xsl:otherwise>
         <xsl:value-of select="false()"/>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template readWriteAttributes -->



<!--
   This template builds a home implementation classname.

   @param _homeImplNode   The framework implementation node to visit.
   @param _scoped         If set to true then the template will append a scope to the classname.
-->
<xsl:template name="buildHomeImplClassname">
   <xsl:param name="_homeImplNode"/>
   <xsl:param name="_scoped" select="true()"/>
   <xsl:param name="_prefix" select="''"/>

   <xsl:choose>
      <xsl:when test="boolean($_homeImplNode/@classname)">
         <xsl:choose>
            <xsl:when test="$_scoped">
               <xsl:value-of select="$_homeImplNode/@classname"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:call-template name="getLastToken">
                  <xsl:with-param name="_string" select="$_homeImplNode/@classname"/>
                  <xsl:with-param name="_separator" select="$xmlSep"/>
               </xsl:call-template>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
         <xsl:variable name="homeName">
            <xsl:call-template name="getLastToken">
               <xsl:with-param name="_string" select="$_homeImplNode/../@factory-idref"/>
               <xsl:with-param name="_separator" select="$xmlSep"/>
            </xsl:call-template>
         </xsl:variable>
         <xsl:variable name="moduleName" select="substring-before($_homeImplNode/../@factory-idref, concat($xmlSep,$homeName))"/>
         <xsl:variable name="homeCategory">
            <xsl:choose>
               <xsl:when test="$_homeImplNode/@category = 'ENTITY'">
                  <xsl:text>Entity</xsl:text>
               </xsl:when>
               <xsl:when test="$_homeImplNode/@category = 'SESSION'">
                  <xsl:text>Session</xsl:text>
               </xsl:when>
               <xsl:when test="$_homeImplNode/@category = 'SERVICE'">
                  <xsl:text>Service</xsl:text>
               </xsl:when>
               <xsl:when test="$_homeImplNode/@category = 'PROCESS'">
                  <xsl:text>Process</xsl:text>
               </xsl:when>
            </xsl:choose>
         </xsl:variable>
         <xsl:choose>
            <xsl:when test="$_scoped">
               <xsl:value-of select="concat('Cdmw.CCM.CIF.Cdmw', $moduleName, $xmlSep, $_prefix, $homeCategory, $homeName, '_impl')"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="concat($_prefix, $homeCategory, $homeName, '_impl')"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template buildHomeImplClassname -->



<!--
   This template returns true if a program node refers to a home-impl framework.

   @param _programNode   The program node to visit.
   @param _only          If set to true(), the template returns true() only if 
                         there are exclusively home-impl frameworks.
-->
<xsl:template name="containsHomeImpl">
   <xsl:param name="_programNode"/>
   <xsl:param name="_only" select="false()"/>

   <!--
      References to some nodes.
   -->
   <xsl:variable name="frameworkNodes" select="$_programNode/services/lifecycle/framework"/>

   <xsl:variable name="searchResult">
      <xsl:for-each select="$frameworkNodes">
         <xsl:variable name="frameworkNode" select="."/>
         <xsl:variable name="lifecycleFrameworkNode" select="$lifecycleFrameworkNodes[@id = $frameworkNode/@idref]"/>
         <xsl:choose>
            <xsl:when test="$lifecycleFrameworkNode/home-impl">
               <xsl:value-of select="true()"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="false()"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each>
   </xsl:variable>

   <xsl:choose>
      <xsl:when test="contains($searchResult, 'true')">
         <xsl:choose>
            <xsl:when test="$_only">
               <xsl:choose>
                  <xsl:when test="contains($searchResult, 'false')">
                     <xsl:value-of select="false()"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:value-of select="true()"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="true()"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
         <xsl:value-of select="false()"/>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template containsHomeImpl -->



<!--
   This template returns true() if a component has either :
   <ul>
      <li>one or more facets
      <li>one or more receptacles
      <li>one or more emitters
      <li>one or more publishers
      <li>one or more consumers
   </ul>

   @param _componentName   The name of the component to visit.
   @param _whatToFind      Can be either 'CCMProvides' or 'CCMUses', ...
-->
<xsl:template name="componentElements">
   <xsl:param name="_componentName"/>
   <xsl:param name="_whatToFind"/>

   <!--
      References to some nodes.
   -->
   <xsl:variable name="componentNode" select="key('classByName', $_componentName)"/>

   <!--
      Miscellaneous variables.
   -->
   <xsl:variable name="ccmComponentId" select="key('stereotypeByName', 'CCMComponent')/@xmi.id"/>
   <xsl:variable name="ccmId" select="key('stereotypeByName', $_whatToFind)/@xmi.id"/>
   <xsl:variable name="nodes" select="key('associationByStereotypeId', $ccmId)[UML:Association.connection/UML:AssociationEnd[1]/@type = $componentNode/@xmi.id]"/>
   <xsl:variable name="generalizations" select="key('generalizationById', $componentNode/UML:GeneralizableElement.generalization/UML:Generalization/@xmi.idref)"/>

   <xsl:variable name="searchResult">
      <xsl:if test="count($nodes) > 0">
         <xsl:value-of select="true()"/>
      </xsl:if>

      <!--
         Look for inherited facets.
      -->
      <xsl:for-each select="$generalizations">
         <xsl:variable name="superClassNode" select="key('classById', UML:Generalization.supertype/UML:GeneralizableElement/@xmi.idref)"/>
         <xsl:if test="$superClassNode/@stereotype = $ccmComponentId">
            <xsl:call-template name="componentElements">
               <xsl:with-param name="_componentName" select="$superClassNode/@name"/>
               <xsl:with-param name="_whatToFind" select="$_whatToFind"/>
            </xsl:call-template>
         </xsl:if>
      </xsl:for-each>
   </xsl:variable>

   <xsl:choose>
      <xsl:when test="contains($searchResult, 'true')">
         <xsl:value-of select="true()"/>
      </xsl:when>
      <xsl:otherwise>
         <xsl:value-of select="false()"/>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template> <!-- end of template componentElements -->



<!--
   This template takes in a program node and check all the lifecycle
   framework nodes for eventual event ports. If at least one event port
   is found, the template returns true().

   @param _programNode   The program node to visit.
-->
<xsl:template name="containsEventPorts">
   <xsl:param name="_programNode"/>
   <!--
      Parameters below are used for recursiveness.
   -->
   <xsl:param name="_index" select="1"/>
   <xsl:param name="_result" select="''"/>

   <xsl:variable name="frameworkNodes" select="$_programNode/services/lifecycle/framework"/>

   <xsl:if test="boolean($frameworkNodes)">
      <xsl:choose>
         <xsl:when test="$_index &lt;= count($frameworkNodes)">
            <xsl:variable name="frameworkNode" select="$frameworkNodes[$_index]"/>

            <!--
               Referred lifecycle-framework.
            -->
            <xsl:variable name="lifecycleFrameworkNode" select="$lifecycleFrameworkNodes[@id = $frameworkNode/@idref]"/>

            <xsl:choose>
               <xsl:when test="$lifecycleFrameworkNode/home-impl">
                  <!--
                     Get the managed component.
                  -->
                  <xsl:variable name="managedComponentId">
                     <xsl:call-template name="getManagedComponentId">
                        <xsl:with-param name="_homeName">
                           <xsl:call-template name="getLastToken">
                              <xsl:with-param name="_string" select="$lifecycleFrameworkNode/@factory-idref"/>
                              <xsl:with-param name="_separator" select="$xmlSep"/>
                           </xsl:call-template>
                        </xsl:with-param>
                     </xsl:call-template>
                  </xsl:variable>
                  <xsl:variable name="managedComponentNode" select="key('classById', $managedComponentId)"/>

                  <!--
                     Find event ports.
                  -->
                  <xsl:variable name="hasEmits">
                     <xsl:call-template name="componentElements">
                        <xsl:with-param name="_componentName" select="$managedComponentNode/@name"/>
                        <xsl:with-param name="_whatToFind" select="'CCMEmits'"/>
                     </xsl:call-template>
                  </xsl:variable>
                  <xsl:variable name="hasPublishes">
                     <xsl:call-template name="componentElements">
                        <xsl:with-param name="_componentName" select="$managedComponentNode/@name"/>
                        <xsl:with-param name="_whatToFind" select="'CCMPublishes'"/>
                     </xsl:call-template>
                  </xsl:variable>
                  <!--
                     Proceed to the next framework.
                  -->
                  <xsl:call-template name="containsEventPorts">
                     <xsl:with-param name="_programNode" select="$_programNode"/>
                     <xsl:with-param name="_index" select="$_index + 1"/>
                     <xsl:with-param name="_result" select="concat($_result, ' ', $hasEmits, ' ', $hasPublishes)"/>
                  </xsl:call-template>
               </xsl:when>
               <xsl:otherwise>
                  <!--
                     Proceed to the next framework.
                  -->
                  <xsl:call-template name="containsEventPorts">
                     <xsl:with-param name="_programNode" select="$_programNode"/>
                     <xsl:with-param name="_index" select="$_index + 1"/>
                     <xsl:with-param name="_result" select="$_result"/>
                  </xsl:call-template>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:otherwise>
            <xsl:choose>
               <xsl:when test="contains($_result, 'true')">
                  <xsl:value-of select="true()"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:value-of select="false()"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:if>
</xsl:template> <!-- end of template containsEventPorts -->


<!--
   Find the namespace for the specific typeNode 
-->
<xsl:template name="findTheNamespaceForTheSpecificNode">
   <xsl:param name="_node"/>
   <xsl:param name="_result" select="''"/>


<xsl:choose>
   <xsl:when test="boolean($_node/@namespace)">
      <xsl:variable name="_nodeModule" select="key('moduleById', $_node/@namespace)"/>
      <xsl:choose>
         <xsl:when test="$_result = ''">
	       <xsl:call-template name="findTheNamespaceForTheSpecificNode">
	          <xsl:with-param name="_node" select="$_nodeModule"/>
	          <xsl:with-param name="_result" select="$_nodeModule/@name"/>
	       </xsl:call-template>
         </xsl:when>
         <xsl:otherwise>
	    <xsl:choose>
               <xsl:when test="boolean($_nodeModule/@name)">
	             <xsl:call-template name="findTheNamespaceForTheSpecificNode">
		        <xsl:with-param name="_node" select="$_nodeModule"/>
		        <xsl:with-param name="_result" select="concat($_nodeModule/@name, $xmlSep, $_result)"/>
	             </xsl:call-template>
	       </xsl:when>
	       <xsl:otherwise>
                     <xsl:call-template name="findTheNamespaceForTheSpecificNode">
	                <xsl:with-param name="_node" select="$_nodeModule"/>
	                <xsl:with-param name="_result" select="$_result"/>
	             </xsl:call-template>
	       </xsl:otherwise>
	    </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:when>
   <xsl:otherwise>
      <xsl:value-of select="$_result"/>
   </xsl:otherwise>
</xsl:choose>

</xsl:template>


<!--
   Find xmi.id for the specific module 
-->
<xsl:template name="findAttributeNodeForTheModule.content">
   <xsl:param name="__nodes"/>
   <xsl:param name="__module"/>
   <xsl:param name="__attribute"/>
   <xsl:param name="__index" select="1"/>

   <xsl:choose>
      <xsl:when test="$__index &lt;= count($__nodes)">
         <xsl:variable name="namespaceForTheNode">
	    <xsl:call-template name="findTheNamespaceForTheSpecificNode">
	       <xsl:with-param name="_node" select="$__nodes[$__index]"/>
	    </xsl:call-template>
	 </xsl:variable>
	 <xsl:choose>
	    <xsl:when test="contains($__module,$namespaceForTheNode)">
	       <xsl:choose>
	          <xsl:when test="$__attribute = 'xmi.id'">
		     <xsl:value-of select="$__nodes[$__index]/@xmi.id"/>
		  </xsl:when>
		  <xsl:when test="$__attribute = 'stereotype'">
		     <xsl:value-of select="$__nodes[$__index]/@stereotype"/>
		  </xsl:when>
		  <xsl:otherwise>
		     <xsl:message terminate="yes">
		        <xsl:value-of select="concat('FAILURE : The attribute is not defined.')"/>
		     </xsl:message>
		  </xsl:otherwise>
	       </xsl:choose>
	    </xsl:when>
	    <xsl:otherwise>
	       <xsl:call-template name="findAttributeNodeForTheModule.content">
	          <xsl:with-param name="__nodes" select="$__nodes"/>
		  <xsl:with-param name="__module" select="$__module"/>
		  <xsl:with-param name="__attribute" select="$__attribute"/>
		  <xsl:with-param name="__index" select="$__index + 1"/>
	       </xsl:call-template>
	    </xsl:otherwise>
	 </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
         <xsl:value-of select="''"/>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template>


<!--
   Find xmi.id for the specific module 
-->                 
<xsl:template name="findAttributeNodeForTheModule">
   <xsl:param name="_module"/>
   <xsl:param name="_attribute"/>

   <xsl:variable name="_moduleBaseName">
      <xsl:call-template name="getLastToken">
         <xsl:with-param name="_string" select="$_module"/>
         <xsl:with-param name="_separator" select="$xmlSep"/>
      </xsl:call-template>
   </xsl:variable>
   <xsl:variable name="nodes" select="key('classByName', $_moduleBaseName)"/>
   <xsl:variable name="result">
      <xsl:call-template name="findAttributeNodeForTheModule.content">
         <xsl:with-param name="__nodes" select="$nodes"/>
         <xsl:with-param name="__attribute" select="$_attribute"/>
         <xsl:with-param name="__module" select="$_module"/>
      </xsl:call-template>
   </xsl:variable>
   <xsl:choose>
      <xsl:when test="$result=''">
         <xsl:message terminate="yes">
            <xsl:value-of select="concat('FAILURE : The CORBA module ',  $_module, ' does not exist in the XMI document.')"/>
         </xsl:message>
      </xsl:when>
      <xsl:otherwise>
          <xsl:value-of select="$result"/>
      </xsl:otherwise>
   </xsl:choose>
</xsl:template>

</xsl:stylesheet>

