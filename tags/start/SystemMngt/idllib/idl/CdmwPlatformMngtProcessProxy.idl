/* ===================================================================== */
/*
 * This file is part of CARDAMOM (R) which is jointly developed by THALES 
 * and SELEX-SI. 
 * 
 * It is derivative work based on PERCO Copyright (C) THALES 2000-2003. 
 * All rights reserved.
 * 
 * CARDAMOM is free software; you can redistribute it and/or modify it under 
 * the terms of the GNU Library General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your 
 * option) any later version. 
 * 
 * CARDAMOM is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public 
 * License for more details. 
 * 
 * You should have received a copy of the GNU Library General 
 * Public License along with CARDAMOM; see the file COPYING. If not, write to 
 * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/
/* ===================================================================== */


#ifndef CDMW_PLATFORM_MNGT_PROCESS_PROXY_IDL_
#define CDMW_PLATFORM_MNGT_PROCESS_PROXY_IDL_


#include <CdmwPlatformMngtCommon.idl>
#include <CdmwPlatformMngtEntityContainer.idl>
#include <CdmwPlatformMngtServiceContainer.idl>
#include <CdmwPlatformMngtPropertyContainer.idl>
#include <CdmwPlatformMngtActivityPoint.idl>
#include <CdmwPlatformMngtHostProxy.idl>

#pragma prefix "thalesgroup.com"

module CdmwPlatformMngt
{

   // interface HostProxy;


    /**
    * The proxy of a process.
    */
    interface ProcessProxy : CdmwPlatformMngtEntity::RWEntityContainer,
        CdmwPlatformMngtService::RWServiceDefContainer,
        RWPropertyContainer, ActivityPointContainer
    {

        /**
        * The name identifying the process.
        */
        readonly attribute ProcessName name;

        /**
        * The type of the process.
        */
        readonly attribute ProcessType type;

        /**
        * The embedded service or NIL if the process
        * is not a service provider.
        */
        readonly attribute Object embedded_service;

        /**
        * Returns the status of the process with its additional information.
        */
        ProcessStatus get_status(out string status_info);

        /**
        * Indicates whether the process ends itself.
        */
        boolean is_autoending();
        
        /**
        * Sets the process as ending itself.
        *
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        void set_autoending()
            raises(IncompatibleStatus);

        /**
        * Returns the host where the process runs.
        */
        HostProxy get_host();

        /**
        * Changes the host where the process will be running.
        *
        * @param host_name the name of the host.
        * @exception HostNotFound if the host is unknown.
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        void set_host(in HostName host_name)
            raises(HostNotFound, IncompatibleStatus);

        /**
        * Returns the information needed for the process creation.
        */
        ProcessInfo get_process_info();

        /**
        * Changes the information needed for the process creation.
        *
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        void set_process_info(in ProcessInfo process_info)
            raises(IncompatibleStatus);

        /**
        * Returns the lifecycle of the process.
        *
        * @exception IncompatibleType if the process is not a managed process.
        */
        LifeCycleDef get_life_cycle()
            raises(IncompatibleType);

        /**
        * Changes the lifecycle of the process.
        *
        * @exception DuplicateStep if the definition of the lifecycle
        * has a duplicate step.
        * @exception IncompatibleType if the process is not a managed process.
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        void set_life_cycle(in LifeCycleDef life_cycle)
            raises(DuplicateStep, IncompatibleType, IncompatibleStatus);

        /**
        * Returns the information about the monitoring of the process.
        *
        * @exception IncompatibleType if the process is not a managed process.
        */
        CompleteMonitoringInfo get_monitoring_info()
            raises(IncompatibleType);

        /**
        * Changes the information about the monitoring of the process.
        *
        * @exception IncompatibleType if the process is not a managed process.
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        void set_monitoring_info(in CompleteMonitoringInfo monitoring_info)
            raises(IncompatibleType, IncompatibleStatus);

        /**
        * Returns the definition of activity points.
        *
        * @exception IncompatibleType if the process is not a managed process.
        */
        ActivityPointDefs get_activity_point_defs()
            raises(IncompatibleType);

        /**
        * Changes the definition of activity points.
        *
        * @exception DuplicateActivityPoint if there is a duplicate name
        * among the definition of activity points.
        * @exception IncompatibleType if the process is not a managed process.
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        void set_activity_point_defs(in ActivityPointDefs point_defs)
            raises(DuplicateActivityPoint, IncompatibleType, IncompatibleStatus);

        /**
        * Returns a snapshot of the process.
        */
        ProcessSnapshot get_snapshot();

        /**
        * Creates the actual process and starts its initialisation if it
        * is a managed process.
        *
        * @param startup_kind the startup kind of the whole system.
        * @return the status of the request.
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        RequestStatus initialise(in CdmwPlatformMngtBase::StartupKind startup_kind)
            raises(IncompatibleStatus);
        
        /**
        * Requests the managed process to perform its next step.
        *
        * @return the status of the request.
        * @exception InvalidStep if there is no step to perform.
        * @exception IncompatibleType if the process is not a managed process.
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        RequestStatus next_step()
            raises(InvalidStep, IncompatibleType, IncompatibleStatus);

        /**
        * Requests the managed process to run.
        *
        * @return the status of the request.
        * @exception NotReadyToRun if the process has not been requested
        * to perform all its necessary initialisation steps.
        * @exception IncompatibleType if the process is not a managed process.
        * @exception IncompatibleStatus if the status of the process doesn't
        * allow the operation.
        */
        RequestStatus run()
            raises(NotReadyToRun, IncompatibleType, IncompatibleStatus);

        /**
        * Requests the process to stop properly if it is a managed process
        * or kills it if it is an unmanaged process.
        *
        * @param emergency if true, the managed process will be killed
        * immediately without requested to stop properly. Irrelevant for
        * an unmanaged process.
        * @return the status of the request.
        */
        RequestStatus stop(in boolean emergency);

    }; // End interface ProcessObserver


    /**
    * The sequence of ProcessProxy.
    */
    typedef sequence<ProcessProxy> ProcessProxies;


    /**
    * The iterator for ProcessProxies.
    */
    interface ProcessProxiesIterator
    {
        void reset();

        boolean next_one(out ProcessProxy process_proxy);

        boolean next_n(in unsigned long how_many,
                   out ProcessProxies process_proxies);

        void destroy();
    };



}; // End Module CdmwPlatformMngt

#endif // CDMW_PLATFORM_MNGT_PROCESS_PROXY_IDL_

