/* ===================================================================== */
/*
 * This file is part of CARDAMOM (R) which is jointly developed by THALES
 * and SELEX-SI. It is derivative work based on PERCO Copyright (C) THALES
 * 2000-2003. All rights reserved.
 * 
 * Copyright (C) THALES 2004-2005. All rights reserved
 * 
 * CARDAMOM is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Library General Public License as published
 * by the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * CARDAMOM is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with CARDAMOM; see the file COPYING. If not, write to the
 * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/
/* ===================================================================== */


#ifndef _CDMW_FT_REPLICATION_MANAGER_LOCATION_H_
#define _CDMW_FT_REPLICATION_MANAGER_LOCATION_H_

#include <list>
#include <map>

#include "ftreplicationmanager/ReplicationManagerDelegate.hpp"
#include "ftreplicationmanager/CdmwFTLocationInfo.stub.hpp"
#include "ftreplicationmanager/Location_sm.h"
#include "ftreplicationmanager/Object.hpp"

namespace Cdmw {
namespace  FT {
namespace ReplicationManager {

namespace ObjectGroup {
    // Forward
    class ObjectGroup;
}
    
namespace Location {


    /**
     * Location: the context class tied with the generated Location_sm
     * state machine. This class is actually part of the ReplicationManager,
     * hence its declaration within the ReplicationManager namespace. The 
     * additional namespace "Location" is needed to avoid name clashes in
     * include files provided by the state machine generation tool (SMC)
     * when more than one machine is nested in the same namespace.
     */
    class Location {
    
      private:

        LocationContext _fsm;

      public:

        /**
         * Creates an ObjectGroup context.
         *
         */
        Location ( const std::string &           name
                 , ReplicationManagerDelegate*   rep_mgr);
        
        /**
         * Destroys an ObjectGroup context.
         */
        ~Location();

        // -------- Methods called by the replication manager --------
          
        const std::string& name()      { return m_locname; }

        /*
         * Returns 'true' if the location is primary, false else.
         */
//        bool is_primary()              { return ! m_is_backup; }
        bool is_primary()              { 
            if  ((m_fsm_state == CdmwFT::LocationState_PRIMARY) || 
                 (m_fsm_state == CdmwFT::LocationState_INSERTING_PRIMARY))
                return true;            
            else
                return false;
        }
        

        /*
         * Returns the list containing copies of ObjectGroupData for
         * each location group.
         */
        void
        get_members_ogd (std::list < ::CdmwFT::ObjectGroupData_var > & ogd_list)
            throw( ::CORBA::INTERNAL);
        
        /*
         * Association/Disassociation ObjectGroup/Location
         */
        void associate_object_group (
                   ::FT::ObjectGroupId             ogid
                 , ObjectGroup::ObjectGroup&       objgrp);
        bool disassociate_object_group (
                   ::FT::ObjectGroupId             ogid);

        /*
         * Association/Disassociation Location/Objects
         *
         * throw BAD_INV_ORDER if attempting to associate an object
         * while the Location does not exist (NULL loc pointer)
         */
        void associate_object (
                   ::FT::ObjectGroupId             ogid
                 , Object::Object&                 object)
            throw(::CORBA::BAD_INV_ORDER);
        bool disassociate_object (
                   ::FT::ObjectGroupId             ogid);

        /*
         * Disassociate the current Location from its ObjectGroup and Objects
         */
        void disassociate ();
        
        ObjectGroup::ObjectGroup* get_grpctxt(::FT::ObjectGroupId ogid);
        Object::Object*           get_objctxt(::FT::ObjectGroupId ogid);
        
        /*
         * Clears the inetrnal map and force the SMC machine to INITIAL state
         */
        void reset ();
        
        /*
         * Forces the SMC machine to unconditionally go to state 'fsm_state'.
         * The value to pass is the internal encoding generated by the SMC
         * compiler. Ther's no documented way to set a relation between the
         * IDL state enumeration and the internal SMC enumeration. The caller
         * should therefore use a SMC state obtained by a piece of code such
         * as 'smc_state = _fsm.getState().getId()' which returns the current
         * internal state.
         */
        void restore_fsm_state (int fsm_state);
        
        /*
         * Add a primary member to the Location: called back by _fsm
         */
        void
        add_primary ( ObjectGroup::ObjectGroup&    objgrp
                 , Object::Object&                 objctxt
                 , ::CORBA::Object_ptr             member
                 , const ::FT::Location&           primary_loc)
            throw( CdmwFT::Location::InitFailed
                 , CdmwFT::Location::AlreadyDone
                 , CdmwFT::Location::UnknownDataStoreID
                 , CdmwFT::StateTransfer::InvalidDataStoreState
                 , ::CORBA::SystemException);


        /*
         * Add a backup member to the Location: called back by _fsm
         */
        void
        add_backup ( ObjectGroup::ObjectGroup&     objgrp
                 , Object::Object&                 objctxt
                 , ::CORBA::Object_ptr             member
                 , const ::FT::Location&           primary_loc)
            throw( ::CORBA::SystemException);

        /*
         * Update the primary when the Location switches to PRIMARY state
         */
        void
        update_primary (const ::FT::Location& primary_loc)
            throw( ::CORBA::INTERNAL
	     , ::CORBA::SystemException);

        /*
         * Update all the group views when the Location switches to BACKUP state
         */
        void
        update_all_group_views ()
            throw( ::CORBA::INTERNAL
		   , ::CORBA::SystemException);
        
        
        /*
         * Switches all the members to PRIMARY
         */
        void
        set_primary()
            throw( ::CORBA::INTERNAL
		   , ::CORBA::SystemException);

        /*
         * Switches all the members to BACKUP
         */
        void
        set_backup()
            throw( ::CORBA::INTERNAL
		   , ::CORBA::SystemException);

        /*
         * 
         */
        void
        remove_members ()
            throw( ::FT::MemberNotFound,
                   ::CORBA::INTERNAL
		   , ::CORBA::SystemException);

        /*
         * 
         */
        ::FT::ObjectGroup_ptr
        remove_member (::FT::ObjectGroupId  ogid)
            throw( ::FT::ObjectGroupNotFound
                 , ::CORBA::SystemException);

        /*
         * Removes the pair (this->get_key, this) from the ContextContainer.
         */
        bool
        remove_from_container ();
        
        // -------- Methods related to the location state machine ----
          
        /**
         * Transitions of this machine: these methods call the peer fsm
         * methods which in turn call back the Location method with the
         * same name without the 'ev_' prefix.
         */
        void ev_create_object()
            throw( ::CORBA::INTERNAL);

        void ev_set_backup()
            throw( ::CORBA::INTERNAL);

        void ev_add_member(
                   ObjectGroup::ObjectGroup&       grpctxt
                 , Object::Object&                 objctxt
                 , ::CORBA::Object_ptr             member
                 , const ::FT::Location&           primary_loc)
            throw( ::CORBA::INTERNAL);

        void ev_set_primary()
            throw( ::CORBA::INTERNAL);

        void ev_failure()
            throw( ::CORBA::INTERNAL);

        /*
         * Called back by ev_failure action code
         */
        void failure()
            throw( ::CORBA::INTERNAL);

        /*
         * Actions called while a transition is occuring: public because
         * called by the classes generated by the SMC tool
         */
        void exp_add_member(int value) { m_exp_add_member = value;}
        int  exp_add_member()          { return m_exp_add_member; }
        void inc_exp_add_member()      { m_exp_add_member++;}
        void dec_exp_add_member()      { m_exp_add_member--;}
        void members_count(int value)  { m_members_count = value; }
        int  members_count()           { return m_members_count; }
        void inc_members_count()       { m_members_count++; }
        void dec_members_count()       { m_members_count--; }
        void backup(bool value)        { m_is_backup = value; }
        bool backup()                  { return m_is_backup; }
        bool first_backup()            { return m_first_backup; }
        void first_backup(bool value)  { m_first_backup = value; }
        

        /*
         * Try to set the flag 'first_backup' to the requested value.
         * If successfull, saves the new value in the DataStore and returns.
         * If unsuccessfull, throws a < to be defined > exception.
         */
        void set_first_backup(bool first_backup_flag)
            throw ( ::CORBA::INTERNAL);
        // #### FIXME: define an additional exception if the flag could not be set.

        /*
         * Called by the Location which receives the first add_member: tells
         * the peer Locations to insert their future members as BACKUP.
         */
        void set_peers_to_initial_backup();


        CdmwFT::LocationState fsm_state()                { return m_fsm_state; }
        int fsm_internal_state()                         { return _fsm.getState().getId();}

        // #### WARNING - WARNING - WARNING - WARNING - WARNING - WARNING ####
        // This modifier is **RESERVED** it **MUST NOT** be used in a regular
        // CARDAMOM code or it will lead to an inconsistent machine state
        void fsm_state(CdmwFT::LocationState state)      { m_fsm_state = state; }
        void fsm_internal_state(int state)               { _fsm.setState(_fsm.valueOf(state)); }
        // #### WARNING - WARNING - WARNING - WARNING - WARNING - WARNING ####

        CdmwFT::LocationStateness stateness()            { return m_stateness; }
        void stateness(CdmwFT::LocationStateness state)  { m_stateness = state; }

        // List of group/member couples belonging to this Location
        struct Infos {
            Infos() : grp(NULL), obj(NULL) { }
            ObjectGroup::ObjectGroup* grp;
            Object::Object*           obj;
        };
        typedef std::map  < ::FT::ObjectGroupId, Infos > InfosMap;
        
        InfosMap& get_infos() { return m_infos; }

        /*
         * Return the list of the replicated Locations *including* the caller.
         * It does not modify the list if it is called before a create_object
         * involving this Location has not yet been processed by the Rep.Mgr.
         */
        void      get_peer_locations (std::list < Location* > & loc_list);
        unsigned  peer_locations_number();
          
        /*
         * Returns the peer Location in the PRIMARY state, or NULL if
         * there's currently no PRIMARY Location, or if called before
         * a create_object involving this Location has not yet been
         * processed by the Rep.Mgr.
         */
        Location* get_peer_primary ();
          
      private:

        typedef std::pair < ::FT::ObjectGroupId, Infos > InfosPair;

        int                            m_members_count;
        int                            m_exp_add_member;
        bool                           m_is_backup;
        ::CdmwFT::LocationStateness    m_stateness;

        /*
         * NOTE: SMC doesn't generate a header file containing the
         *       declaration of symbolic constants for its internal
         *       machine state. IDL files contain declaration of
         *       state values to save in DataStore. That's why we
         *       need to save both kinds of state.
         */
        ::CdmwFT::LocationState        m_fsm_state;
        //int                            m_fsm_internal_state;
        int                            m_fsm_initial_state;
        std::string                    m_locname;
        ReplicationManagerDelegate*    m_rep_mgr;
        bool                           m_first_backup;

        // Associated ObjectGroups and Objects
        InfosMap                       m_infos;


      private:

        // Hide the default constructor.
        Location(void);
        
        // Hide the copy constructor.
        Location(const Location & loc);
        
    };

}; // namespace Location
}; // namespace ReplicationManager
}; // namespace FT
}; // namespace Cdmw

#endif // _CDMW_FT_REPLICATION_MANAGER_LOCATION_H_

